<?xml version="1.0" encoding="utf-8"?>
<search>
  
  <!-- 主题依赖的图标库，不要自行修改 -->
  
  <entry>
    <title>节拍发生2器的原理</title>
    <link href="/2021/04/14/CCEXP07/"/>
    <url>/2021/04/14/CCEXP07/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h2 id="连续节拍发生器"><a href="#连续节拍发生器" class="headerlink" title="连续节拍发生器"></a>连续节拍发生器</h2><p><img src="https://z3.ax1x.com/2021/04/14/c6YWPf.jpg"></p><h3 id="D-触发器的原理"><a href="#D-触发器的原理" class="headerlink" title="D-触发器的原理"></a>D-触发器的原理</h3><h4 id="D-触发器"><a href="#D-触发器" class="headerlink" title="D-触发器"></a>D-触发器</h4><p>D-触发器就是一个一位的寄存器。</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>对于D触发器，其CLR的优先级大于PRN，PRN优先级又大于CLK。</p><table><thead><tr><th>引脚</th><th>作用</th></tr></thead><tbody><tr><td>CLK</td><td>上升沿触发，相当于把D的值存进触发器，使Q的值一直为D，除非被清零。</td></tr><tr><td>PRN</td><td>让Q强制输出1。不管CLK如何。</td></tr><tr><td>CLR</td><td>清零。只要其有效，Q端就是0.</td></tr></tbody></table><h3 id="连续节拍发生器原理"><a href="#连续节拍发生器原理" class="headerlink" title="连续节拍发生器原理"></a>连续节拍发生器原理</h3><p>一开始RST为0，节拍2、3、4对应的触发器的CLR处于有效状态，输出都是0；节拍1对应的触发器的PRN有效，在不受CLK的控制下强制输出1，所以脉冲会呈现第一拍常亮的状态；</p><p>将RST置为1，则第二拍触发器立即置为1，并输出1；与此同时第一拍触发器立即置为0，并输出0.</p><p>在第二拍内，四个触发器的Q端分别是0100.下一脉冲到达时，第三拍触发器被第二排的输出置1，同时第二拍触发器置0.以此类推。随着拍数增加，拍子的编号总是对4取模的。当发生器工作了起来，四个触发器就是平等的了。</p><p>当RST变为0时，2、3、4拍的触发器都被清零并无法被赋值。节拍停止发生。</p><h2 id="单步节拍发生器"><a href="#单步节拍发生器" class="headerlink" title="单步节拍发生器"></a>单步节拍发生器</h2><p><img src="https://z3.ax1x.com/2021/04/14/c6Y2IP.jpg"></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>这个发生器和前者的区别在于它由五个触发器构成。</p><h4 id="关于顶上那个或非门"><a href="#关于顶上那个或非门" class="headerlink" title="关于顶上那个或非门"></a>关于顶上那个或非门</h4><p>第一拍的输入是由四个节拍的脉冲或非而来。这意味着，如果发生器正在工作，则第一拍永远输入0，这样可以防止错乱（即在后续的脉冲点亮的时候，第一拍又发出一次脉冲）。</p><h4 id="如何实现暂停发生"><a href="#如何实现暂停发生" class="headerlink" title="如何实现暂停发生"></a>如何实现暂停发生</h4><p>在第五拍的整个过程中，第五个触发器都是输出高电平，但是此过程中节拍信号是先下降沿，后上升沿。下降沿发生在节拍的中间位置，上升沿发生在节拍末尾。由于第五拍的输出与节拍进行或运算，在第五拍中，实际到达触发器的CLK信号都是恒为高电平。</p><p>因此可以认为，第五排拍，第五个触发器的持续高电平把CLK的上升沿掩盖了。触发器需要上升沿才能被触发，但是所有触发器都收不到上升沿（包括关键的第一号触发器），整个发生器就处于暂停状态了。</p><h4 id="如何恢复节拍发生"><a href="#如何恢复节拍发生" class="headerlink" title="如何恢复节拍发生"></a>如何恢复节拍发生</h4><p>但是注意：在第五拍时，第五个触发器输出1，且前四个触发器都是0，此时第一个触发器有1的输入。这意味着，虽然发生器暂停了工作，但是一号触发器是一直有高电平输入的。因此，如果此时给予一个清零信号，五号触发器被清零，则上升沿将不再被掩盖，一号触发器就可以在收到上升沿时直接触发一个高电平信号，整个发生器又开始运行了。</p>]]></content>
    
    
    <categories>
      
      <category>计算机组成与设计</category>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDUOJ 划分石头题解 (二分查找)</title>
    <link href="/2021/04/13/SDUOJ013/"/>
    <url>/2021/04/13/SDUOJ013/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>海边有很多好看的石头🪨，war把它们收集起来依次排成一排，一共n个，第i个石头的重量为w_i<em>w**i</em>。他想将其分成m段，每一段连续，并且<strong>重量和</strong>最大的段的<strong>和最小</strong>。请你帮帮他～</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行为n(1≤n≤10^5)(1≤<em>n</em>≤105)，m(m≤n)(<em>m</em>≤<em>n</em>)。</p><p>第二行n个数，第i个数为w_i(0≤wi≤10^9)<em>w**i</em>(0≤<em>w**i</em>≤109)，中间有空格。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出只有一个数，<strong>重量和</strong>最大的段的和。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="算法数据"><a href="#算法数据" class="headerlink" title="算法数据"></a>算法数据</h4><table><thead><tr><th>标识符</th><th>解释</th></tr></thead><tbody><tr><td>stones[0..100010]</td><td>存储石头的重量</td></tr><tr><td>maxMass</td><td>界定二分查找的下界</td></tr><tr><td>inputSum</td><td>界定二分查找的上界</td></tr></tbody></table><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h4 id="二分答案：最小化最大值"><a href="#二分答案：最小化最大值" class="headerlink" title="二分答案：最小化最大值"></a>二分答案：最小化最大值</h4><p>根据输入，确定上述上下界，开始二分查找。</p><p>判断函数的关键，在于输入一个判断值d作为每段的质量，判断尽量<code>以此为最小质量</code>，能否分得<code>&lt;=m</code>段。因为如果d过小，显然分段数量要很大。如果d足够大了，分段数量就可以&lt;=m，那么显然<code>能满足</code>“可以分到m段”的条件。</p><p>具体实现方式在于，按顺序遍历所有石头，并计算当前段的质量和。如果当前质量和+下一石头质量超过了d，则分段数++，其余量归零。</p><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>可以通过输入来确定二分答案的上下界，加快速度。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int INF &#x3D; 1e9;unordered_map&lt;int, int&gt; stones;int n, m;int maxMass, inputSum;bool C(int d) &#123;int massSum &#x3D; 0, divides &#x3D; 0;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;if (massSum + stones[i] &gt; d) &#123;divides++;massSum &#x3D; stones[i];&#125;else massSum +&#x3D; stones[i];&#125;if (divides &gt;&#x3D; m)return false;return true;&#125;void solve() &#123;int lb &#x3D; maxMass, ub &#x3D; inputSum, mid &#x3D; 0, ans &#x3D; 0;while (lb&lt;&#x3D;ub)&#123;mid &#x3D; (ub + lb) &#x2F; 2;if (C(mid)) &#123;ans &#x3D; mid;ub &#x3D; mid - 1;&#125;else lb &#x3D; mid + 1;&#125;cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123;&#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.in&quot;,&quot;r&quot;,stdin);&#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.out&quot;, &quot;w&quot;, stdout);cin &gt;&gt; n &gt;&gt; m;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;cin &gt;&gt; stones[i]; if (stones[i] &gt; maxMass)maxMass &#x3D; stones[i];inputSum +&#x3D; stones[i];&#125;solve();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>SDUOJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDUOJ TT与可怜的猫题解 (水题)</title>
    <link href="/2021/04/12/SDUOJ008/"/>
    <url>/2021/04/12/SDUOJ008/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>自从 TT 成为了助教，他就热衷于给同学们解答疑问，于是他就没有时间进行陪他的猫猫玩了，真是一只可怜的小猫。</p><p><img src="https://oj.qd.sdu.edu.cn/api/filesys/download/158001115693068325/TTandCat.png" alt="TTandCat.png"></p><p>TT 在同一时间会与很多同学同时用 QQ（TT特供版） 进行答疑，有时 TT <strong>开启</strong>一个新的窗口，开始一个新的答疑对话；有时 TT <strong>关闭</strong>一个窗口，结束一段答疑； 有时，为了及时回答着急的同学，TT会把一个对话窗口设置为<strong>置顶</strong>状态（置顶状态是一种虚拟的状态，窗口的实际位置并不会发生改变）。</p><p>你可以将 TT 的聊天窗口想象成一个队列。如果现在没有窗口处于<strong>置顶</strong>状态，那么在队列中位列第一窗口视为在<strong>顶层</strong>，否则处于<strong>置顶</strong>状态的窗口视为在<strong>顶层</strong>。请注意，不可能同时存在两个窗口处于<strong>置顶</strong>状态（也就是说，处于置顶状态的窗口，要么不存在，要么只有一个）。如果当前<strong>置顶</strong>的窗口被关闭了，则剩余队列中第一窗口视为在<strong>顶层</strong>。</p><p>TT 为了安抚自己的猫，于是给猫猫看自己的聊天记录解闷，根据猫猫看屏幕中窗口的时间，TT 给每个窗口分配了一个<strong>喜爱度</strong>，TT 认为<strong>喜爱度</strong>越高，猫猫越开心。由于猫猫具有不确定的生物特性，所以所有的<strong>喜爱度</strong>都是<strong>不同</strong>的。</p><p>作为 TT 特供版QQ的研发人员，你要负责完成的工作是为软件记录 TT 的操作，形成一个日志系统。日志有固定的记录格式：<code>OpId #X: MSG.</code> ，其中 X<em>X</em> 是操作的编号，而 <code>MSG</code> 是日志的提示信息，需要使用特定的字符串进行替换。</p><p>TT 可能会用到的操作如下：</p><ol><li><strong>Add u:</strong> TT 打开一个喜爱度为 u<em>u</em> 的新窗口，若 u<em>u</em> 不与当前窗口队列中的某个窗口重复，则该新窗口将新建成功，并成为窗口队列中的最后一个窗口。 如果创建成功，则 <code>MSG</code> 记录 <code>success</code>。 否则， <code>MSG</code> 记录 <code>same likeness </code>。</li><li><strong>Close u:</strong> TT 关掉了一个喜爱度为 u<em>u</em> 的窗口，如果该窗口存在，则将其关闭，<code>MSG</code> 记录 <code>close u with c</code>，u<em>u</em> 表示喜爱度，c<em>c</em> 表示该窗口上次打开至今交流的话的数量。若该窗口不存在，则<code>MSG</code> 记录<code>invalid likeness</code>。</li><li><strong>Chat w:</strong> TT 和<strong>顶层</strong>窗口交流了 w<em>w</em> 句话，如果当前队列中没有窗口，则<code>MSG</code> 记录<code>empty</code>，否则记录 <code>success</code>。</li><li><strong>Rotate x:</strong> 将队列中第 x<em>x</em> 个窗口放在队首，若 x<em>x</em> 大于当前队列中窗口数或小于 11 ，则<code>MSG</code> 记录<code>out of range</code>，否则记录<code>success</code>。举个例子，目前队列中有喜爱度为 5,3,2,8 的四个窗口，Rotate 3 之后，会将喜爱度为 2 的第 3 个窗口放在首位，结果为 2,5,3,8。</li><li><strong>Prior:</strong> TT 将目前喜爱度最大的窗口放在队首，如果当前队列中没有窗口，则<code>MSG</code> 记录<code>empty</code>，否则记录 <code>success</code>。</li><li><strong>Choose u:</strong> TT 将喜爱度为 u<em>u</em> 的窗口放在队首，如果喜爱度为 u<em>u</em> 的窗口存在，则<code>MSG</code> 记录<code>success</code>，否则记录<code>invalid likeness</code>。</li><li><strong>Top u:</strong> TT 将喜爱度为 u<em>u</em> 的窗口设定为<strong>置顶</strong>状态，如果喜爱度为 u<em>u</em> 的窗口存在，则<code>MSG</code> 记录<code>success</code>，否则记录<code>invalid likeness</code>。注意，处于<strong>置顶</strong>状态的窗口最多不超过一个，也就是说，如果在此次设定前已经有处于置顶状态的窗口，则原有<strong>置顶</strong>状态的窗口的<strong>置顶</strong>状态将会消失。（<strong>置顶</strong>只是一种虚拟的状态，原窗口在队列中的位置不会发生变化）</li><li><strong>Untop:</strong> TT 取消当前处于<strong>置顶</strong>状态窗口的<strong>置顶</strong>状态。如果当前没有窗口处于<strong>置顶</strong>状态，则<code>MSG</code> 记录<code>no such person</code>，否则记录<code>success</code>。</li></ol><p>最后，由于TT要给自己的猫猫树立一个讲文明有礼貌的榜样，所以在上述操作完成后，还要进行若干次操作，这些操作是：与当前队列中所有说过话的窗口说拜拜。<code>MSG</code> 记录<code>Bye u: c</code>， u<em>u</em> 表示喜爱度，c<em>c</em> 表示该窗口上次打开至今交流的话的数量。即：TT 先和位于<strong>顶层</strong>的窗口说拜拜，然后将其关闭，如果TT没有和当前<strong>顶层</strong>窗口说过话，则直接将其关闭，如此操作下去，直到队列为空。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>第一行包含一个整数 T (T \leq 5)<em>T</em>(<em>T</em>≤5)，表示数据组数。</p><p>对于每组数据，第一行一个 n<em>n</em>，表示执行的操作数，其中 0&lt;n\leq 50000&lt;<em>n</em>≤5000。接下来 n<em>n</em> 行，每行输入一个操作，保证所有输入数据中的整数不大于 10^9109。</p><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>对于每个指定的操作，按照日志的格式，每个操作行。对于最后的非指定操作，同样按照日志的格式，每个操作一行。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>比较简单的模拟</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;int dataGroupCnt;int opCnt;&#x2F;&#x2F;本组操作数量string curOp;&#x2F;&#x2F;当前操作ll curArg;ll topped &#x3D; -1;deque&lt;ll&gt; windows;set&lt;ll&gt; windowsSet;unordered_map&lt;ll, ll&gt; chatsPerWindow;const char opid[] &#x3D; &quot;OpId #&quot;, col[] &#x3D; &quot;: &quot;, dot[] &#x3D; &quot;.&quot;;int main() &#123;    &#x2F;&#x2F; freopen(&quot;&#x2F;home&#x2F;linton&#x2F;Desktop&#x2F;CSP&#x2F;a.in&quot;, &quot;r&quot;, stdin);    &#x2F;&#x2F; freopen(&quot;&#x2F;home&#x2F;linton&#x2F;Desktop&#x2F;CSP&#x2F;a.out&quot;, &quot;w&quot;, stdout);    &#x2F;&#x2F; freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.in&quot;, &quot;r&quot;, stdin);    &#x2F;&#x2F; freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.out&quot;, &quot;w&quot;, stdout);    cin &gt;&gt; dataGroupCnt;    while (dataGroupCnt--)    &#123;        cin &gt;&gt; opCnt;        for (int o &#x3D; 1; o &lt;&#x3D; opCnt; o++)        &#123;            cin &gt;&gt; curOp;            if (curOp &#x3D;&#x3D; &quot;Add&quot;) &#123;                scanf(&quot;%lld&quot;, &amp;curArg);                if (!windowsSet.count(curArg)) &#123;                    windowsSet.insert(curArg);                    windows.push_back(curArg);                    printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;success&quot;, dot);                &#125;                else printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;same likeness&quot;, dot);            &#125;            else if (curOp &#x3D;&#x3D; &quot;Close&quot;) &#123;                scanf(&quot;%lld&quot;, &amp;curArg);                if (windowsSet.count(curArg)) &#123;                    if (topped &#x3D;&#x3D; curArg)topped &#x3D; -1;                    windowsSet.erase(curArg);                    windows.erase(find(windows.begin(), windows.end(), curArg));                    printf(&quot;%s%lld%s%s%lld%s%lld%s\n&quot;, opid, o, col, &quot;close &quot;, curArg, &quot; with &quot;, chatsPerWindow[curArg], dot);                    chatsPerWindow[curArg] &#x3D; 0;                &#125;                else printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;invalid likeness&quot;, dot);            &#125;            else if (curOp &#x3D;&#x3D; &quot;Chat&quot;) &#123;                scanf(&quot;%lld&quot;, &amp;curArg);                if (topped !&#x3D; -1) &#123;                    printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;success&quot;, dot);                    chatsPerWindow[topped] +&#x3D; curArg;                &#125;                else &#123;                    if (!windows.empty()) &#123;                        printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;success&quot;, dot);                        chatsPerWindow[windows.front()] +&#x3D; curArg;                    &#125;                    else printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;empty&quot;, dot);                &#125;            &#125;            else if (curOp &#x3D;&#x3D; &quot;Rotate&quot;) &#123;                scanf(&quot;%lld&quot;, &amp;curArg);                if (curArg &gt; windows.size()||curArg&lt;1)printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;out of range&quot;, dot);                else &#123;                    auto ite &#x3D; windows.begin();                    ite +&#x3D; curArg - 1;                    int value &#x3D; *ite;                    windows.erase(ite);                                      windows.push_front(value);                    printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;success&quot;, dot);                &#125;            &#125;            else if (curOp &#x3D;&#x3D; &quot;Prior&quot;) &#123;                if (!windows.empty()) &#123;                    int maxLikeness &#x3D; *(windowsSet.rbegin());                    auto ite &#x3D; find(windows.begin(), windows.end(), maxLikeness);                    int value &#x3D; *ite;                    windows.erase(ite);                                       windows.push_front(value);                    printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;success&quot;, dot);                &#125;                else printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;empty&quot;, dot);            &#125;            else if (curOp &#x3D;&#x3D; &quot;Choose&quot;) &#123;                scanf(&quot;%lld&quot;, &amp;curArg);                if (windowsSet.count(curArg)) &#123;                    auto ite &#x3D; find(windows.begin(), windows.end(), curArg);                    int value &#x3D; *ite;                    windows.erase(ite);                                                   windows.push_front(value);                    printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;success&quot;, dot);                &#125;                else printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;invalid likeness&quot;, dot);            &#125;            else if (curOp &#x3D;&#x3D; &quot;Top&quot;) &#123;                scanf(&quot;%lld&quot;, &amp;curArg);                if (windowsSet.count(curArg)) &#123;                    topped &#x3D; curArg;                    printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;success&quot;, dot);                &#125;                else printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;invalid likeness&quot;, dot);            &#125;            else if (curOp &#x3D;&#x3D; &quot;Untop&quot;) &#123;                if (topped !&#x3D; -1) &#123;                    printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;success&quot;, dot);                    topped &#x3D; -1;                &#125;                else printf(&quot;%s%lld%s%s%s\n&quot;, opid, o, col, &quot;no such person&quot;, dot);            &#125;&#x2F;&#x2F;  for(auto i&#x3D; windows.begin();i!&#x3D;windows.end();i++)cout&lt;&lt;*i&lt;&lt;&quot;,&quot;&lt;&lt;chatsPerWindow[*i]&lt;&lt;&quot; &quot;;&#x2F;&#x2F;         cout&lt;&lt;endl;        &#125;        int curUser &#x3D; 0;        &#x2F;&#x2F; for(auto i&#x3D; windows.begin();i!&#x3D;windows.end();i++)cout&lt;&lt;*i&lt;&lt;&quot;,&quot;&lt;&lt;chatsPerWindow[*i]&lt;&lt;&quot; &quot;;        &#x2F;&#x2F; cout&lt;&lt;endl;        if(topped!&#x3D;-1)&#123;            if (chatsPerWindow[topped])printf(&quot;%s%lld%s%s%lld%s%lld%s\n&quot;, opid, ++opCnt, col, &quot;Bye &quot;, topped, &quot;: &quot;, chatsPerWindow[topped], dot);            windows.erase(find(windows.begin(), windows.end(), topped));        &#125;                while (!windows.empty())        &#123;            curUser &#x3D; windows.front();            if (chatsPerWindow[curUser]) printf(&quot;%s%lld%s%s%lld%s%lld%s\n&quot;, opid, ++opCnt, col, &quot;Bye &quot;, curUser, &quot;: &quot;, chatsPerWindow[curUser], dot);            windows.pop_front();        &#125;        topped &#x3D; -1;        windowsSet.clear();        chatsPerWindow.clear();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>SDUOJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDUOJ 时间复杂度题解 (模拟)</title>
    <link href="/2021/04/12/SDUOJ009/"/>
    <url>/2021/04/12/SDUOJ009/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>分析算法的时间复杂度是评价算法性能的重要方式之一，对于同一问题来说，拥有线性时间复杂度的算法往往比拥有平方级别时间复杂度的算法要快很多，因此拥有线性时间复杂度的算法往往优于拥有平方级别时间复杂度的算法。</p><p>通常，可以根据输入n的值确定算法的运行时间，n可以表示要排序的对象数，多边形顶点数等等。现给出一段简易的程序，程序规则如下，其中<number>可以是任何非负整数：</p><div class="code-wrapper"><pre class="line-numbers language-language" data-language="language"><code class="language-language">&lt; Program &gt; ::&#x3D; &quot;BEGIN&quot; &lt; Statementlist &gt; &quot;END&quot; &lt; Statementlist &gt; ::&#x3D; &lt; Statement &gt; | &lt; Statement &gt; &lt; Statementlist &gt; &lt; Statement &gt; ::&#x3D; &lt; LOOP-Statement &gt; | &lt; OP-Statement &gt; &lt; LOOP-Statement &gt; ::&#x3D; &lt; LOOP-Header &gt; &lt; Statementlist &gt; &quot;END&quot; &lt; LOOP-Header &gt; ::&#x3D; &quot;LOOP&quot; &lt; number &gt; | &quot;LOOP n&quot; &lt; OP-Statement &gt; ::&#x3D; &quot;OP&quot; &lt; number &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>针对该规则下的程序的运行时间可以如下计算：执行OP语句所花费的时间与其参数指定的时间相同（即为number）。LOOP语句到其对应的END之间所有语句执行的次数与LOOP后的参数相同（即为number或n）。程序运行时间是其组成部分的时间总和。因此，总运行时间通常取决于n。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入一段程序，空格和换行符可以出现在程序中的任何位置，但不能出现在关键字BEGIN，END，LOOP和OP中或整数值中。LOOP的循环嵌套深度最多为10。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>以n为单位输出程序的运行时间，即输出一个化简后的Y（Y&lt;=10）次多项式，形如“Runtime = a<em>n^10+b</em>n^9+ . . . +i<em>n^2+ j</em>n+k”，若n的某一项系数为0则直接省略该项,若系数为1则省略其系数。<br>如果运行时间为0，则只需打印 “Runtime = 0”。</p><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><div class="code-wrapper"><pre class="line-numbers language-language" data-language="language"><code class="language-language">BEGIN   LOOP n     LOOP n       OP 3       OP 4       LOOP 4         OP 3       END     END   END   OP 7END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><div class="code-wrapper"><pre class="line-numbers language-language" data-language="language"><code class="language-language">Runtime &#x3D; 19*n^2+7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>Runtime = n*(n*(3+4+4<em>3))+7=19</em>n^2+7</p><h3 id="数据范围说明"><a href="#数据范围说明" class="headerlink" title="数据范围说明"></a>数据范围说明</h3><p>LOOP循环嵌套深度&lt;=10且关键字总数不超过50<br>且所有运算均在int范围内进行<br>对于测试点1，保证只包含OP语句<br>对于测试点2,3，保证只有一段Statementlist且只有一层循环<br>对于测试点4，保证只有一段Statementlist</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="输入过程中的数据结构"><a href="#输入过程中的数据结构" class="headerlink" title="输入过程中的数据结构"></a>输入过程中的数据结构</h4><table><thead><tr><th>标识符</th><th>解释</th></tr></thead><tbody><tr><td>depth</td><td>当前嵌套层数</td></tr><tr><td>args[0…14]</td><td>下标的含义是n的幂次。表示最终化简式中，对应n的此幂次的项系数（多开余量）</td></tr><tr><td>ops[0…14]</td><td>对应depth的这一层的循环次数。</td></tr><tr><td>op</td><td>当前关键字。包括LOOP、BEGIN、END、OP。</td></tr><tr><td>op2</td><td>第二关键字。</td></tr><tr><td>cur_arg</td><td>当前处理输入所在的层数往回走，记录经过的嵌套层的所有循环次数的乘积（指数字，除了n）。</td></tr><tr><td>n_depth</td><td>当前处理输入所在的层数往回走，记录一共经过了多少层循环次数为n的嵌套层。</td></tr></tbody></table><h4 id="解答过程中的数据结构"><a href="#解答过程中的数据结构" class="headerlink" title="解答过程中的数据结构"></a>解答过程中的数据结构</h4><table><thead><tr><th>标识符</th><th>解释</th></tr></thead><tbody><tr><td>fa</td><td>用于标志当前项是否为式子的第一项（即前面无需跟“+”）。</td></tr><tr><td>fb</td><td>用于标志整个程序的复杂度是否对于n的各个幂次来说，都是0.如果各个幂次都是0，则可以直接输出time=0.</td></tr></tbody></table><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h4 id="处理输入，并当场完成“多项式化简”"><a href="#处理输入，并当场完成“多项式化简”" class="headerlink" title="处理输入，并当场完成“多项式化简”"></a>处理输入，并当场完成“多项式化简”</h4><p>维护depth，一开始为0.</p><p>开始while循环，当depth=-1时结束。因为这时读入了程序结束的那个END。</p><p>每次处理时，分三种情况。</p><p>如果读入END，则depth–即可。因为END了，下一次再处理读入时，就从上一级做即可。</p><p>如果读入LOOP，则若n，记录当前depth的ops为-1，否则为操作数。即把这层循环的次数记录下来。</p><p>如果读入OP，则初始化cur_arg和n_depth，从它的上层(即depth-1)开始循环，一直到0层，考察本层的循环次数。如果为n则n_depth++，否则cur_arg直接乘循环次数。最后处理n_depth，即让n幂次为n_depth的系数加上刚才的cur_arg*操作数即可。这样就站在某个幂次的n的角度，更新了其前面的系数。</p><h4 id="处理前面化简好的n的各次幂的系数，并按幂次从高到低输出"><a href="#处理前面化简好的n的各次幂的系数，并按幂次从高到低输出" class="headerlink" title="处理前面化简好的n的各次幂的系数，并按幂次从高到低输出"></a>处理前面化简好的n的各次幂的系数，并按幂次从高到低输出</h4><p>维护fa，fb，都先初始化为0.</p><p>循环11次（因为幂次取值范围是0…10），每次循环先检查args[i]是否为0：</p><p>如果为0说明这一项不存在（因为系数是0），跳过。</p><p>如果不为0说明这一项的系数就是args[i]。</p><p>args[i]不为零，进入打印的过程：先把fb置1。</p><p>每次打印，分fa为1和为0两种情况。如果为0，则打印时加个“+”，否则不加。当然每次打印如果fa=0，则立即置1.</p><p>打印只需要对i==0、i==1两种情况进行特殊处理。前者是n不加”^”,后者是不含n。</p><p>走完11次循环，如果fb仍为0，则单独处理，输出time=0即可。</p><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>千万不能去模拟手动化简多项式的过程。否则非常麻烦。</p><p>在输入的过程中直接针对n的各个幂次计算他们的系数，高效而精妙。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int ops[15];int args[15];string op, op2;int fa, fb;int depth;int cur_arg, n_depth;int sti(string str)&#123;int res &#x3D; 0;for (int i &#x3D; 0; i &lt; str.length(); i++)res &#x3D; res * 10 + str[i] - &#39;0&#39;;return res;&#125;void solve() &#123;cout &lt;&lt; &quot;Runtime &#x3D; &quot;;fa &#x3D; fb &#x3D; 0;for (int i &#x3D; 11; i &gt;&#x3D; 0; i--)&#123;if (args[i] &#x3D;&#x3D; 0)continue;else &#123;fb &#x3D; 1;if (i &#x3D;&#x3D; 0)&#123;if (fa &#x3D;&#x3D; 0)&#123;fa &#x3D; 1;cout &lt;&lt; args[i];&#125;else cout &lt;&lt; &quot;+&quot; &lt;&lt; args[i];&#125;else if (i &#x3D;&#x3D; 1)&#123;if (fa &#x3D;&#x3D; 0)&#123;fa &#x3D; 1;if (args[i] !&#x3D; 1) cout &lt;&lt; args[i] &lt;&lt; &quot;*n&quot;;else cout &lt;&lt; &quot;n&quot;;&#125;else&#123;if (args[i] !&#x3D; 1) cout &lt;&lt; &quot;+&quot; &lt;&lt; args[i] &lt;&lt; &quot;*n&quot;;else cout &lt;&lt; &quot;+n&quot;;&#125;&#125;else&#123;if (fa &#x3D;&#x3D; 0)&#123;fa &#x3D; 1;if (args[i] !&#x3D; 1)cout &lt;&lt; args[i] &lt;&lt; &quot;*n^&quot; &lt;&lt; i;else cout &lt;&lt; &quot;n^&quot; &lt;&lt; i;&#125;else&#123;if (args[i] !&#x3D; 1) cout &lt;&lt; &quot;+&quot; &lt;&lt; args[i] &lt;&lt; &quot;*n^&quot; &lt;&lt; i;else cout &lt;&lt; &quot;+n^&quot; &lt;&lt; i;&#125;&#125;&#125;&#125;if (fb &#x3D;&#x3D; 0)cout &lt;&lt; 0;puts(&quot;\n&quot;);&#125;int main()&#123;&#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.in&quot;, &quot;r&quot;, stdin);&#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.out&quot;, &quot;w&quot;, stdout);ios::sync_with_stdio(false);cin &gt;&gt; op;depth &#x3D; 0;memset(args, 0, sizeof(args));while (depth !&#x3D; -1)&#123;cin &gt;&gt; op;if (op &#x3D;&#x3D; &quot;LOOP&quot;)&#123;cin &gt;&gt; op2;if (op2 &#x3D;&#x3D; &quot;n&quot;) ops[depth++] &#x3D; -1;else ops[depth++] &#x3D; sti(op2);&#125;else if (op &#x3D;&#x3D; &quot;END&quot;)depth--;else if (op &#x3D;&#x3D; &quot;OP&quot;)&#123;cin &gt;&gt; op2;cur_arg &#x3D; 1;n_depth &#x3D; 0;for (int j &#x3D; depth - 1; j &gt;&#x3D; 0; j--)&#123;if (ops[j] &#x3D;&#x3D; -1)n_depth++;else cur_arg &#x3D; cur_arg * ops[j];&#125;args[n_depth] &#x3D; args[n_depth] + cur_arg * sti(op2);&#125;&#125;solve();return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>SDUOJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDUOJ 公路修建题解 (并查集)</title>
    <link href="/2021/04/12/SDUOJ010/"/>
    <url>/2021/04/12/SDUOJ010/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>你现在是城市的主人<br>现在有 n<em>n</em> 个村庄，要修建 m<em>m</em> 条路，每修建一条路，道路是双向的，输出至少还需要修建几条，可以让所有村庄互相可达。<br>一开始路为 00 条</p><p>数据保证有解</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数 n,m<em>n</em>,<em>m</em> , 0\le n,m\le10^50≤<em>n</em>,<em>m</em>≤105<br>接下来有 m<em>m</em> 行，每行 a,b<em>a</em>,<em>b</em> 代表修建了一条从第 a<em>a</em> 个村庄，到第 b<em>b</em> 个村庄的路。<br>1\le a,b\le n1≤<em>a</em>,<em>b</em>≤<em>n</em><br>a<em>a</em> 和 b<em>b</em> 可能相同。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一共 m<em>m</em> 行，第 i<em>i</em> 个数代表已经修建了前 i<em>i</em> 条路时，最少还需要修建几条，可以让所有村庄互相可达。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">5 51 11 22 34 41 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">43222<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><table><thead><tr><th>标识符</th><th>解释</th></tr></thead><tbody><tr><td>parent[0…100005]</td><td>并查集的各个节点的父节点。</td></tr><tr><td>sets</td><td>当前存在的集合（等价类）个数。</td></tr></tbody></table><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h4 id="利用并查集确定等价类个数"><a href="#利用并查集确定等价类个数" class="headerlink" title="利用并查集确定等价类个数"></a>利用并查集确定等价类个数</h4><p>若两个村庄联通，则它们必然属于同一个<code>等价类</code>。</p><p>对于每个输入，就对两个村庄所在集合进行合并。每次合并让sets–即可。</p><p>每次输出当前sets值即可。</p><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>需要进行路径压缩，否则会<code>TLE</code>。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">int getParent(int i) &#123;    if (parent[i] &#x3D;&#x3D; i)return i;    return getParent(parent[i] &#x3D; parent[parent[i]]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><p>带有路径压缩的getParent,即在每次递归调用时进行压缩.</p><p>以与代表元直接邻接的临接的点为例,则它的<code>parent[parent[i]]</code>就是它的父节点的父节点,也就是代表元节点.相当于把它的父节点变成了代表元节点.</p><p>其余节点都按类似的方式往代表元节点靠近一步.整棵并查集树就<code>变扁了</code>.</p><p>以此种方式进行路径压缩,可以达到树高度=1的结果.</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int MOD &#x3D; 1000000007;int n, m, sets, reqA, reqB;int parent[100005];int getParent(int i) &#123;    if (parent[i] &#x3D;&#x3D; i)return i;    return getParent(parent[i] &#x3D; parent[parent[i]]);&#125;void merge(int a, int b) &#123;    int p1 &#x3D; getParent(a);    int p2 &#x3D; getParent(b);    if (p1 !&#x3D; p2) &#123;        parent[p1] &#x3D; p2;        sets--;    &#125;&#125;void solve() &#123;    sets &#x3D; n;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)parent[i] &#x3D; i;    for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;        scanf(&quot;%d %d&quot;, &amp;reqA, &amp;reqB);        merge(reqA, reqB);        cout &lt;&lt; sets - 1 &lt;&lt; endl;    &#125;&#125;int main() &#123;    &#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.in&quot;, &quot;r&quot;, stdin);    &#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.out&quot;, &quot;w&quot;, stdout);    cin &gt;&gt; n &gt;&gt; m;    solve();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>SDUOJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDUOJ 网络铺设题解 (BFS链式前向星)</title>
    <link href="/2021/04/12/SDUOJ011/"/>
    <url>/2021/04/12/SDUOJ011/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>你现在是城市的主人<br>现在有 n<em>n</em> 个村庄，已经修建了 n-1<em>n</em>−1 条道路，使得各个村庄作为节点，路作为边，构成一棵树。<br>假设第 a<em>a</em> 个村庄到第 b<em>b</em> 个村庄有路相连，则从 a<em>a</em> 走到 b<em>b</em> 或者从 b<em>b</em> 走到 a<em>a</em> 需要走 1\text{m}1m 。</p><p>你需要输出 n<em>n</em> 个数，第 i<em>i</em> 个数代表从第 i<em>i</em> 个村庄出发，距离他最远的村庄的距离</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 n<em>n</em> , 0\le n\le10^50≤<em>n</em>≤105<br>接下来有 n-1<em>n</em>−1 行，每行 a,b<em>a</em>,<em>b</em> 代表第 a<em>a</em> 个村庄，到第 b<em>b</em> 个村庄有一条路。<br>1\le a,b\le 10^51≤<em>a</em>,<em>b</em>≤105</p><p>保证输入结构是一棵树</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行 n<em>n</em> 个数，表示答案</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">55 11 22 33 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">3 2 3 4 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="node结构体"><a href="#node结构体" class="headerlink" title="node结构体"></a>node结构体</h4><table><thead><tr><th>标识符</th><th>解释</th></tr></thead><tbody><tr><td>next</td><td>链表节点的next域</td></tr><tr><td>num</td><td>节点编号</td></tr></tbody></table><h4 id="链式前向星的数据"><a href="#链式前向星的数据" class="headerlink" title="链式前向星的数据"></a>链式前向星的数据</h4><table><thead><tr><th>标识符</th><th>解释</th></tr></thead><tbody><tr><td>sn</td><td>最近新建的node在申请空间中的下标</td></tr><tr><td>storage[0…300002]</td><td>存储所有的链表节点</td></tr><tr><td>nodes[0…105001]</td><td>存储所有的头节点</td></tr></tbody></table><h4 id="算法数据"><a href="#算法数据" class="headerlink" title="算法数据"></a>算法数据</h4><table><thead><tr><th>标识符</th><th>解释</th></tr></thead><tbody><tr><td>max1[0..105001]</td><td>从第一个最大的点到各个点的距离</td></tr><tr><td>max2[0..105001]</td><td>从第二个最大的点到各个点的距离</td></tr></tbody></table><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h4 id="构建链式前向星"><a href="#构建链式前向星" class="headerlink" title="构建链式前向星"></a>构建链式前向星</h4><p>先在nodes数组中初始化n个域，表示n个图节点。</p><p>为他们分别<code>安排哨兵</code>：让所有的头节点的next都为num=-1，next=-1.（以后如果要往这个链上插入新点，都是要在头节点和头节点的next之间插入，这样复杂度最低。<code>我们哨兵的作用是无需单独处理这条链为空的情况。</code>）</p><p>写好构建单向边的函数：<code>让sn++，代表申请内存空间</code>，然后按链表的方式操作即可。注意遵循链式前向星的插入方法：即头节点和其next之间。</p><p>写好构建双向边的函数：两次调用上述函数。</p><h4 id="四次BFS解决问题"><a href="#四次BFS解决问题" class="headerlink" title="四次BFS解决问题"></a>四次BFS解决问题</h4><p>这里BFS需要额外加一个操作：每次BFS新节点入队时，记录新节点的距离是当前节点的+1.</p><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>无。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int MOD &#x3D; 1000000007;struct Node&#123;    int next;    int num;    Node() :next(-1), num(-1) &#123;&#125;;&#125;;int n, iv1, iv2, sn;int max1[105001], max2[105001];Node storage[300002];Node nodes[105001];void createEdge(int v1, int v2) &#123;    int newNode &#x3D; ++sn;    storage[newNode].num &#x3D; v2;    storage[newNode].next &#x3D; nodes[v1].next;    nodes[v1].next &#x3D; newNode;&#125;void addNewEdge(int v1, int v2) &#123;    createEdge(v1, v2);    createEdge(v2, v1);&#125;int bfs(int start,bool mode,bool key) &#123;    int cur &#x3D; nodes[start].next;    int last &#x3D; start;    queue&lt;int&gt; q;    set&lt;int&gt; vis;    while (storage[cur].next!&#x3D;-1)    &#123;        q.push(storage[cur].num);        cur &#x3D; storage[cur].next;    &#125;    while (!q.empty())    &#123;        int theNum &#x3D; q.front();        q.pop();        vis.insert(theNum);        last &#x3D; theNum;        cur &#x3D; nodes[theNum].next;        while (storage[cur].next !&#x3D; -1)        &#123;            if (!vis.count(storage[cur].num)) &#123;                q.push(storage[cur].num);                 if (mode)key ? max1[storage[cur].num] &#x3D; max1[theNum] + 1 : max2[storage[cur].num] &#x3D; max2[theNum] + 1;            &#125;            cur &#x3D; storage[cur].next;        &#125;    &#125;    return last;&#125;void solve() &#123;    int far1 &#x3D; bfs(1,false,false);    int far2 &#x3D; bfs(far1,false,false);    bfs(far1, true, true);    bfs(far2, true, false);    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)printf(&quot;%d &quot;, max(max1[i]+1, max2[i]+1));    puts(&quot;\n&quot;);&#125;int main() &#123;    &#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.in&quot;, &quot;r&quot;, stdin);    &#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.out&quot;, &quot;w&quot;, stdout);    cin &gt;&gt; n;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;        int newNode &#x3D; ++sn;        nodes[i].num &#x3D; i;         nodes[i].next &#x3D; newNode;&#x2F;&#x2F;哨兵    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++) &#123;        scanf(&quot;%d %d&quot;, &amp;iv1, &amp;iv2);        addNewEdge(iv1, iv2);    &#125;    solve();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>SDUOJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDUOJ 水渠设计题解 (贪心、最小生成树)</title>
    <link href="/2021/04/12/SDUOJ012/"/>
    <url>/2021/04/12/SDUOJ012/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>你现在是城市的主人<br>现在有 n<em>n</em> 个田地需要灌溉。<br>可以选择修建 m<em>m</em> 个引水渠，第 i<em>i</em> 条从第 a<em>a</em> 个田地到第 b<em>b</em> 个田地，花费 c<em>c</em> 元。<br>现在可以买任意多个抽水机，买一个抽水机需要花费 p<em>p</em> 元。如果在一个田地旁边安置一个抽水机，则该田地会被灌溉。<br>水可以顺着水渠流动。<br>求让每一块田地都能被灌溉的最小花费。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个整数 n,m,p<em>n</em>,<em>m</em>,<em>p</em> , 0\le n,m\le10^5,p\le 10^90≤<em>n</em>,<em>m</em>≤105,<em>p</em>≤109<br>接下来有 m<em>m</em> 行，每行 a,b,c<em>a</em>,<em>b</em>,<em>c</em> 代表修建了一条从第 a<em>a</em> 个田地，到第 b<em>b</em> 个田地的水渠，花费 c<em>c</em> 元。<br>1\le a,b\le n1≤<em>a</em>,<em>b</em>≤<em>n</em>，c&lt;=10^9<em>c</em>&lt;=109</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个数表示答案。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">5 5 21 2 12 3 33 4 51 3 21 4 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="Edge结构体"><a href="#Edge结构体" class="headerlink" title="Edge结构体"></a>Edge结构体</h4><table><thead><tr><th>标识符</th><th>解释</th></tr></thead><tbody><tr><td>v1,v2</td><td>~</td></tr><tr><td>val</td><td>~</td></tr><tr><td>重载运算符&lt;</td><td>便于堆排序，每次取最小边</td></tr></tbody></table><h4 id="算法数据"><a href="#算法数据" class="headerlink" title="算法数据"></a>算法数据</h4><table><thead><tr><th>标识符</th><th>解释</th></tr></thead><tbody><tr><td>edges堆</td><td>kurskal用</td></tr><tr><td>parent[0…100005]</td><td>并查集用</td></tr><tr><td>sets</td><td>当前等价类的个数</td></tr></tbody></table><h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><h4 id="kruskal中的贪心"><a href="#kruskal中的贪心" class="headerlink" title="kruskal中的贪心"></a>kruskal中的贪心</h4><p>正常使用。但是为了保证成本最低，需要贪心。</p><p>每次操作，有两种选择，其一是增加一共边，让当前的树长大；另一种选择就是保持原来的森林。前者的成本是修路的价格，后者的成本是一个抽水机的价格。那么如果修路比抽水机便宜就修路，否则反之。</p><p>修路要维护set和res(答案)：每次修路，set都–，并且更新答案即可。</p><p>最后统计set个数，就是抽水机个数。让答案再加抽水机个数*价格。</p><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>虽然输入的数据在int范围内，但是它需要与其他数据相乘。这样就会爆int。因此都要用long long。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int MOD &#x3D; 1000000007;struct Edge&#123;    int v1, v2, val;    Edge(int v1_,int v2_,int val_) :v1(v1_), v2(v2_), val(val_)&#123;&#125;;    bool operator&lt;(const Edge&amp; e)const &#123;        return val &gt; e.val;    &#125;;&#125;;int n, m, a, b, c, sn, sets;ll p;int parent[100005];priority_queue&lt;Edge&gt; edges;int getParent(int i) &#123;    if (parent[i] &#x3D;&#x3D; i)return i;    return getParent(parent[i] &#x3D; parent[parent[i]]);&#125;void merge(int a, int b) &#123;    int p1 &#x3D; getParent(a);    int p2 &#x3D; getParent(b);    if (p1 !&#x3D; p2) &#123;         parent[p1] &#x3D; p2;         sets--;    &#125;&#125;void kruskal() &#123;    ll res &#x3D; 0;    while (!edges.empty()) &#123;        Edge e &#x3D; edges.top();        edges.pop();        int par1 &#x3D; getParent(e.v1), par2 &#x3D; getParent(e.v2);        if (par1 !&#x3D; par2 &amp;&amp; e.val &lt; p) &#123;            merge(e.v1, e.v2);            res +&#x3D; e.val;        &#125;    &#125;    res +&#x3D; sets * p;    cout &lt;&lt; res &lt;&lt; endl;&#125;int main() &#123;    &#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.in&quot;, &quot;r&quot;, stdin);    &#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.out&quot;, &quot;w&quot;, stdout);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;    while (m--) &#123;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        edges.emplace(a, b, c);    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)parent[i] &#x3D; i;    sets &#x3D; n;    kruskal();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>SDUOJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文搞懂后缀数组的倍增实现</title>
    <link href="/2021/04/11/SA1/"/>
    <url>/2021/04/11/SA1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是后缀数组-Suffix-Array"><a href="#什么是后缀数组-Suffix-Array" class="headerlink" title="什么是后缀数组 (Suffix Array)"></a>什么是后缀数组 (Suffix Array)</h2><h4 id="前置知识：字符串排序"><a href="#前置知识：字符串排序" class="headerlink" title="前置知识：字符串排序"></a>前置知识：字符串排序</h4><p>对字符串之间的排序我们给出以下定义：</p><p>关于字符串的大小比较,是指通常所说的“字典顺序”比较,也就是对于两个字符串u、v, 令 i 从 1开始顺次比较 u[i] 和 v[i]。</p><p> 如果u[i] = v[i] 则令i加1， 否则若u[i]&lt;vi则认为u&lt;v，u[i]&gt;vi则认为u&gt;v，比较结束。</p><p>如果i&gt;len(u)或者i&gt;len(v)仍比较不出结果，那么若len(u)&lt;len(v)则认为uv，若len(u)=len(v)则认为u=v，若len(u)&gt;len(v)则u&gt;va。</p><h4 id="通俗定义"><a href="#通俗定义" class="headerlink" title="通俗定义"></a>通俗定义</h4><p>后缀是指从某个位置开始到整个串末尾结束的一个特殊子串。后缀数组是SA、RK两个数组的统称。通过这两个数组，我们可以高效地完成某些字符串的处理操作。</p><h4 id="SA数组"><a href="#SA数组" class="headerlink" title="SA数组"></a>SA数组</h4><p>SA数组即Suffix Array。</p><p>先将以下标[1…n]起始的各个子串拿出来，并以单调不降的升序排列。</p><p>SA[i]的含义是在上述排列中，排名i（即第 i 小）的子串是从哪个下标起始的。</p><h4 id="RK数组"><a href="#RK数组" class="headerlink" title="RK数组"></a>RK数组</h4><p>RK数组即Rank。</p><p>先将以下标[1…n]起始的各个子串拿出来，并以单调不降的升序排列。</p><p>RK[i]的含义是以下标i为起始的子串，它在上述排列中排名第几（即第几小）。</p><h4 id="RK和SA数组的关系"><a href="#RK和SA数组的关系" class="headerlink" title="RK和SA数组的关系"></a>RK和SA数组的关系</h4><p>显然有：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">RK[SA[i]]&#x3D;i，SA[RK[i]]&#x3D;i.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>即它们是互逆运算。</p><h2 id="生成后缀数组的朴素方法-堆排序"><a href="#生成后缀数组的朴素方法-堆排序" class="headerlink" title="生成后缀数组的朴素方法 (堆排序)"></a>生成后缀数组的朴素方法 (堆排序)</h2><h4 id="先看代码"><a href="#先看代码" class="headerlink" title="先看代码"></a>先看代码</h4><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void init(int* sa,int* rk,const string&amp; str) &#123;saString* suffixStrs &#x3D; new saString[str.length() + 1];priority_queue&lt;saString&gt; heap;stack&lt;saString&gt; stk;for (int i &#x3D; 1; i &lt;&#x3D; str.length(); i++) &#123;suffixStrs[i].val &#x3D; str.substr(i - 1); suffixStrs[i].begin &#x3D; i;heap.push(suffixStrs[i]);&#125;while (!heap.empty())&#123;stk.push(heap.top());heap.pop();&#125;int rank &#x3D; 0;while (!stk.empty())&#123;sa[++rank] &#x3D; stk.top().begin;rk[stk.top().begin] &#x3D; rank;stk.pop();&#125;delete[]suffixStrs;&#125;&#x2F;&#x2F;比较两个字符串的复杂度是O（n），堆排序是O（nlogn），故整体是O（n^2logn）.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="基于倍增算法的生成方法"><a href="#基于倍增算法的生成方法" class="headerlink" title="基于倍增算法的生成方法"></a>基于倍增算法的生成方法</h2><h4 id="先看代码-1"><a href="#先看代码-1" class="headerlink" title="先看代码"></a>先看代码</h4><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">void doubleHeapSort(compPair* cp,int* order,const int&amp; len,int&amp; subLen) &#123;&#x2F;&#x2F;利用堆排序，时间复杂度为O（nlogn）&#x2F;&#x2F;cp:待比较的&#x2F;&#x2F;order:比较结果输出&#x2F;&#x2F;len:字符串长度for (int i &#x3D; 1; i &lt;&#x3D; len; i++) &#123;if (i + subLen &lt;&#x3D; len) &#123;cp[i].first &#x3D; order[i];cp[i].second &#x3D; order[i + subLen];&#125;else &#123;cp[i].first &#x3D; order[i]; cp[i].second &#x3D; 0;&#125;cp[i].index &#x3D; i;&#125;priority_queue&lt;compPair&gt; heap;for (int i &#x3D; 1; i &lt;&#x3D; len; i++) &#123; heap.push(cp[i]); &#125;int rank &#x3D; 0;compPair last;while (!heap.empty())&#123;if (heap.top() &lt; last) &#123;rank++; last &#x3D; heap.top(); &#125;order[heap.top().index] &#x3D; rank;heap.pop();&#125;subLen *&#x3D; 2;&#125;void initMSA(int* sa, int* rk, const string&amp; str) &#123;&#x2F;&#x2F;为倍增进行初始化、对第一行进行初始排序，时间复杂度为O（nlogn）compChar* cc &#x3D; new compChar[str.length()];for (int i &#x3D; 0; i &lt; str.length(); i++) &#123;cc[i].c &#x3D; str[i]; cc[i].index &#x3D; i + 1;&#125;priority_queue&lt;compChar&gt; heapC;for (int i &#x3D; 0; i &lt; str.length(); i++)heapC.push(cc[i]);int stCRank &#x3D; 0;char last &#x3D; 0;int* order &#x3D; new int[str.length() + 1];while (!heapC.empty())&#123;if (heapC.top().c &gt; last) &#123; stCRank++; last &#x3D; heapC.top().c; &#125;order[heapC.top().index] &#x3D; stCRank;heapC.pop();&#125;&#x2F;&#x2F;循环执行倍增算法，时间复杂度为O（nlog^2(n)）compPair* cp &#x3D; new compPair[str.length() + 1];for (int subLen &#x3D; 1; subLen*2&lt;&#x3D;str.length();) doubleHeapSort(cp, order, str.length(),subLen);&#x2F;&#x2F;拷贝结果到rk数组,顺便生成sa数组for (int i &#x3D; 1; i &lt;&#x3D; str.length(); i++) &#123;rk[i] &#x3D; order[i]; sa[rk[i]] &#x3D; i;&#125;delete[]order, cp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h3><h4 id="直观感受”倍增“"><a href="#直观感受”倍增“" class="headerlink" title="直观感受”倍增“"></a>直观感受”倍增“</h4><p>拿DNA扩增过程中，DNA双链的总数举例，则每次扩增，其总数都乘2.</p><p>在这个关系中，可以认为”DNA双链总数“满足倍增的关系。</p><p>倍增，就是每次乘2.</p><h4 id="后缀数组中的倍增"><a href="#后缀数组中的倍增" class="headerlink" title="后缀数组中的倍增"></a>后缀数组中的倍增</h4><p>在后缀数组算法中，倍增是指每个子串的最大长度每次乘2.</p><p>为什么提最大长度？因为对于起始下标较大的子串，它们可能达不到这个值。</p><h4 id="倍增算法的优势"><a href="#倍增算法的优势" class="headerlink" title="倍增算法的优势"></a>倍增算法的优势</h4><p>暴力法求SA、RK数组，则需要O（n）的字符串比较和O（nlogn）的排序，加起来是O（n^2logn）。</p><p>如果不去比较字符串，而是只把各个子串以SA数组元素的方式呈现，则字符串的比较将降低至O（1）的。如果采用倍增，则需要logn次循环即可增到一个最大长度为n的子串。</p><p>则若使用快速排序或堆排序，算法复杂度是O（nlog^2(n)）。</p><h4 id="还有很大的优化空间"><a href="#还有很大的优化空间" class="headerlink" title="还有很大的优化空间"></a>还有很大的优化空间</h4><p>由于我们的RK数组的大小介于ASCII码个数（128）到源字符串长度之间，我们的RK数组的规模不会很大。如果我们将O（nlogn）的排序降低至O（n）的级别，那么是非常舒服的。</p><p>我们将得到一个O（nlogn）的算法，或准确地说是O（2nlogn）的。</p><p>因此引入通过两次执行计数排序，实现的双关键字基数排序的算法。</p><h2 id="基于多关键字基数排序的倍增算法"><a href="#基于多关键字基数排序的倍增算法" class="headerlink" title="基于多关键字基数排序的倍增算法"></a>基于多关键字基数排序的倍增算法</h2><h3 id="先看代码-2"><a href="#先看代码-2" class="headerlink" title="先看代码"></a>先看代码</h3><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">int i, m, p, w;n &#x3D; strlen(s + 1);m &#x3D; max(n, 128);&#x2F;&#x2F;英文字符下，ASCII最多128个for (int i &#x3D; 1; i &lt;&#x3D; n; i++)cnt[rk[i] &#x3D; s[i]]++;for (int i &#x3D; 1; i &lt;&#x3D; m; i++)cnt[i] +&#x3D; cnt[i - 1];for (int i &#x3D; n; i &gt;&#x3D; 1; i--)sa[cnt[rk[i]]--] &#x3D; i;for (w &#x3D; 1; w &lt; n; w &lt;&lt;&#x3D; 1) &#123;    memset(cnt, 0, sizeof(cnt));    memcpy(id, sa, sizeof(sa));    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)cnt[rk[sa[i]+w]]++;&#x2F;&#x2F;+w在[]外面！    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)cnt[i] +&#x3D; cnt[i - 1];    for (int i &#x3D; n; i &gt;&#x3D; 1; i--)sa[cnt[rk[id[i]+w]]--] &#x3D; id[i];&#x2F;&#x2F;此处是id[i]!    memset(cnt, 0, sizeof(cnt));    memcpy(id, sa, sizeof(sa));    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)cnt[rk[sa[i]]]++;    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)cnt[i] +&#x3D; cnt[i - 1];    for (int i &#x3D; n; i &gt;&#x3D; 1; i--)sa[cnt[rk[id[i]]]--] &#x3D; id[i];    memcpy(oldrk, rk, sizeof(rk));    for (p &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; i++) oldrk[sa[i]] &#x3D;&#x3D; oldrk[sa[i - 1]] &amp;&amp; oldrk[sa[i] + w] &#x3D;&#x3D; oldrk[sa[i - 1] + w] ? rk[sa[i]] &#x3D; p : rk[sa[i]] &#x3D; ++p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><table><thead><tr><th>变量</th><th>解释</th></tr></thead><tbody><tr><td>s[N]</td><td>源字符串</td></tr><tr><td>n</td><td>源字符串长度</td></tr><tr><td>rk[N]</td><td>rk数组</td></tr><tr><td>sa[N]</td><td>sa数组</td></tr><tr><td>oldrk[N]</td><td>相对于本轮的双关键字基数排序，上一轮双关键字基数排序完成后计算出的rk数组的快照</td></tr><tr><td>id[N]</td><td>每次计数排序前的sa的快照</td></tr><tr><td>cnt[N]</td><td>用于计数排序</td></tr><tr><td>i</td><td>循环下标，无需每次新建了</td></tr><tr><td>m</td><td>计数排序中最大期望的出现的名次的个数</td></tr><tr><td>p</td><td>双关键字基数排序后，计算新rk时，代表本轮排名（每次+1）</td></tr><tr><td>w</td><td>倍增偏移量</td></tr></tbody></table><h3 id="基础算法思想"><a href="#基础算法思想" class="headerlink" title="基础算法思想"></a>基础算法思想</h3><h4 id="第一趟计数排序"><a href="#第一趟计数排序" class="headerlink" title="第一趟计数排序"></a>第一趟计数排序</h4><p>先进行一趟计数排序，确定子串长度为1时的rk和sa。</p><p>此处由于串长为1，故rk可以写入对应下标的char的ASCII码代替。它们天生有rk数组的那种对于字符串单调不降的性质。</p><p>对于aabaaaab样例，此时的rk数组为：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">97 97 98 97 97 97 97 98 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>其中，97是a的ASCII码，98是b的ASCII码。</p><p>此时的sa数组为：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1 2 4 5 6 7 3 8 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>每个元素代表以其元素值开始的长度为1的子串的单调不降排序情况。</p><p>即:1,2,3,5,6,7代表了a字符，3和8代表了b字符。</p><h4 id="后续的双关键字基数排序"><a href="#后续的双关键字基数排序" class="headerlink" title="后续的双关键字基数排序"></a>后续的双关键字基数排序</h4><p>分别连续对两个关键字进行计数排序，称为双关键字的基数排序。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (w &#x3D; 1; w &lt; n; w &lt;&lt;&#x3D; 1)&#123;    if(w&gt;&#x3D;2)m &#x3D; n;    memset(cnt, 0, sizeof(cnt));&#x2F;&#x2F;注意要初始化cnt数组，所有计数都从0开始。    for (i &#x3D; 1; i &lt;&#x3D; n; ++i) id[i] &#x3D; sa[i];    for (i &#x3D; 1; i &lt;&#x3D; n; ++i) ++cnt[rk[id[i] + w]];    for (i &#x3D; 1; i &lt;&#x3D; m; ++i) cnt[i] +&#x3D; cnt[i - 1];    for (i &#x3D; n; i &gt;&#x3D; 1; --i) sa[cnt[rk[id[i] + w]]--] &#x3D; id[i];    ....&#x2F;&#x2F;TODO: 再进行一轮对第一关键字的排序&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>以第二关键字的计数排序为例，算法思想如下：</p><p>先将排序前的sa数组存快照到id数组。</p><p>之后开始计数排序的一般步骤。</p><h5 id="循环条件"><a href="#循环条件" class="headerlink" title="循环条件"></a>循环条件</h5><p>w&lt;n，且每次w按位左移。</p><p>这样就能实现所谓倍增。</p><h5 id="rk数组的注意事项"><a href="#rk数组的注意事项" class="headerlink" title="rk数组的注意事项"></a>rk数组的注意事项</h5><p>rk数组要开源字符串长度的2倍大小。</p><p>因为当w=n时，sa[i]+w一般是&gt;w且&lt;2w的。</p><p>如果rk不够大就会<code>当场RE</code>。</p><p>而且，如果我们每次都把该数组初始化为全０，就能方便地达到”若第二关键字的子串不在源数组范围内，则使它的sa为0（也可认为是无穷小）“的效果。</p><h5 id="关于计数各个子串的rank"><a href="#关于计数各个子串的rank" class="headerlink" title="关于计数各个子串的rank"></a>关于计数各个子串的rank</h5><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (i &#x3D; 1; i &lt;&#x3D; n; ++i) ++cnt[rk[id[i] + w]];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>id[i]是sa[i]的快照，随着i的增大，以其对应下标的元素为起始的长度为w/2的子串是依次呈单调不降排列的。</p><p>因此我们只需要让i增加，其对应的rank就是单调不降地被枚举出来的。</p><p>以这种次序，可以完成对各种可能的rank的计数。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="关于求前缀和"><a href="#关于求前缀和" class="headerlink" title="关于求前缀和"></a>关于求前缀和</h5><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (i &#x3D; 1; i &lt;&#x3D; m; ++i) cnt[i] +&#x3D; cnt[i - 1];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>对于计数结果从小到大遍历求和，则可以得到各个计数对应元素的最后一个结果下标。</p><p>这里的循环条件是遍历到m为止。m的定义是期望的计数元素。</p><p>对于w=0情况下的计数排序，rank是以ASCII码的形式存储，故m应当不小于ASCII的最大值128.</p><p>对于w&gt;=2情况下的计数排序，由于在w=1的那次计数排序中，已经更新rank为从1开始的int数，故rank中的值都必然小于等于源字符串的长度。（这个过程下文会介绍）</p><p>因此w=0时，m的初始化如下:</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">m &#x3D; max(n, 128);&#x2F;&#x2F;英文字符下，ASCII最多128个<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>进入w&gt;=2的计数排序时，m剪枝为:</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">if(w&gt;&#x3D;2) m &#x3D; n;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性即排序前B排在A的后面，则排序后B也要排在A的后面才行。由于cnt保存的是计数对应元素的最后一个结果下标，故其能记录下有序性。</p><p>这里有序性是至关重要的。因为对于双关键字的基数排序，我们先对第二关键字进行排序，然后再对第一关键字排序。第一关键字排序是在第二关键字排序的结果基础上进行。在第一关键字排序中，如果两个元素的第一关键字不相等，则会直接抹去第二关键字排序中这两个元素的第二关键字的大小关系。反之，如果第一关键字排序中，这两个元素的关键字相等，则会保留第二关键字排序中原有的大小关系。这种”保留“需要依靠计数排序的稳定性。</p><p>例如：在第二关键字排序上，升序排列为</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">xxxxabxxxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>然而a、b的第一关键字相等，则第一关键字排序后，排序结果仍为</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">xxxxabxxxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>但是设想如果破坏了稳定性，则可能出现</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">xxxxbaxxxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>那么这样就不符合多关键字中的”先考虑第一关键字，如果相等才去考虑第二关键字“的原则了。只有保证了每一步的稳定性，才能确保规则100%成立。</p><h5 id="关于导出排序结果"><a href="#关于导出排序结果" class="headerlink" title="关于导出排序结果"></a>关于导出排序结果</h5><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (i &#x3D; n; i &gt;&#x3D; 1; --i) sa[cnt[rk[id[i] + w]]--] &#x3D; id[i];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p><code>有序性</code>  以倒序遍历cnt数组，以保证排序结果的有序性。</p><p>由于各个id作为下标的情况下，rk[id[i]]是单调不降数组，故我们正在逆序遍历cnt，符合计数排序最后一步的定义。</p><p>将sa更新即可。</p><p>（注：sa数组是不会出现重复元素的。因为它的元素代表子串的起始位置。而每个子串是唯一的。）</p><h5 id="子串的归并"><a href="#子串的归并" class="headerlink" title="子串的归并"></a>子串的归并</h5><p><code>注</code>  虽然这里我们的排序对象是id[i]+w，但是我们的赋值是id[i]。这一个操作就实现了两个子串的<code>归并</code>。</p><h4 id="计算新的rk数组"><a href="#计算新的rk数组" class="headerlink" title="计算新的rk数组"></a>计算新的rk数组</h4><p>按上述方法跑完两趟计数排序，就完成了双关键字的基数排序。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">   memcpy(oldrk, rk, sizeof(rk));&#x2F;&#x2F;获得rk更新前的快照（因为接下来rk就要被更新了）for (p &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; ++i) &#123;     if (oldrk[sa[i]] &#x3D;&#x3D; oldrk[sa[i - 1]] &amp;&amp;         oldrk[sa[i] + w] &#x3D;&#x3D; oldrk[sa[i - 1] + w]) &#123;         rk[sa[i]] &#x3D; p;     &#125;     else &#123;         rk[sa[i]] &#x3D; ++p;     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h5 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h5><p>维护一个p，代表rk数组中此位置的值。</p><p>同样地，正序遍历sa，则得到的rk[sa[i]]是（单调不降的子串序列）（断个句）的首下标。</p><p>由于它们单调不降，我们把新值按单调不降的顺序往rk数组里填即可。从0开始，逐渐上升。</p><h5 id="p是增加，还是不变？"><a href="#p是增加，还是不变？" class="headerlink" title="p是增加，还是不变？"></a>p是增加，还是不变？</h5><p>按单调不降原则，如果当前对象的值和前一个相等，则它们的名次应当相等。此时p还用上一轮的p即可。否则如果不相等，则其名次更新为++p。</p><p>判断”当前对象的值和前一个相等“的方法很简单：由于现在这个子串是由两个串合并（倍增）而来，所以只需要判断合并所需原料完全相等即可。即原来的首关键字相等，第二关键字也相等。</p><h3 id="小优化：使用及时终止的倍增算法"><a href="#小优化：使用及时终止的倍增算法" class="headerlink" title="小优化：使用及时终止的倍增算法"></a>小优化：使用及时终止的倍增算法</h3><p>在每次生成RK数组，都会维护一个p，其等于当前RK数组的值域。即：当前有多少个可区分的单调不降的名次。</p><p>如果每个子串的RK互不相同，则我们认为后缀数组已经生成。利用这个特点，我们做以下优化：</p><p>我们利用这个p，在每次倍增的结束时做以下判断，并直接生成最终的sa数组即可。算法提前结束。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">if (p &#x3D;&#x3D; n) &#123;  for (int i &#x3D; 1; i &lt;&#x3D; n; ++i) sa[rk[i]] &#x3D; i;  break;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="常数优化：减少O-n-次的计数排序"><a href="#常数优化：减少O-n-次的计数排序" class="headerlink" title="常数优化：减少O(n)次的计数排序"></a>常数优化：减少O(n)次的计数排序</h3><p>优化效果：让O(2nlogn)变成O(nlogn)</p><p>老规矩先看代码：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">int i, m, p, w;n &#x3D; strlen(s + 1);m &#x3D; max(n, 128);for (int i &#x3D; 1; i &lt;&#x3D; n; i++)cnt[rk[i] &#x3D; s[i]]++;for (int i &#x3D; 1; i &lt;&#x3D; m; i++)cnt[i] +&#x3D; cnt[i - 1];for (int i &#x3D; n; i &gt;&#x3D; 1; i--)sa[cnt[rk[i]]--] &#x3D; i;for (w &#x3D; 1; w &lt; n; w &lt;&lt;&#x3D; 1) &#123;    memset(cnt, 0, sizeof(cnt));    memcpy(id, sa, sizeof(sa));    for (p &#x3D; 0, i &#x3D; n; i &gt; n - w; --i) id[++p] &#x3D; i;    for (i &#x3D; 1; i &lt;&#x3D; n; ++i) if (sa[i] &gt; w) id[++p] &#x3D; sa[i] - w;    memset(cnt, 0, sizeof(cnt));    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)cnt[rk[sa[i]]]++;    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)cnt[i] +&#x3D; cnt[i - 1];    for (int i &#x3D; n; i &gt;&#x3D; 1; i--)sa[cnt[rk[id[i]]]--] &#x3D; id[i];    memcpy(oldrk, rk, sizeof(rk));    for (p &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; i++) oldrk[sa[i]] &#x3D;&#x3D; oldrk[sa[i - 1]] &amp;&amp; oldrk[sa[i] + w] &#x3D;&#x3D; oldrk[sa[i - 1] + w]? rk[sa[i]] &#x3D; p: rk[sa[i]] &#x3D; ++p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>主要将针对第二关键字的计数排序修改为：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">memcpy(id, sa, sizeof(sa));for (p &#x3D; 0, i &#x3D; n; i &gt; n - w; --i) id[++p] &#x3D; i;for (i &#x3D; 1; i &lt;&#x3D; n; ++i) if (sa[i] &gt; w) id[++p] &#x3D; sa[i] - w;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><p>并去掉针对第一关键字的计数排序的id数组初始化（减少一次赋值）。</p><h4 id="将sa数组中，第二关键字为0的元素拿出来，放到id数组的最开始"><a href="#将sa数组中，第二关键字为0的元素拿出来，放到id数组的最开始" class="headerlink" title="将sa数组中，第二关键字为0的元素拿出来，放到id数组的最开始"></a>将sa数组中，第二关键字为0的元素拿出来，放到id数组的最开始</h4><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (p &#x3D; 0, i &#x3D; n; i &gt; n - w; --i) id[++p] &#x3D; i;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这些元素不会存在第二关键字（或称第二关键字为0），所以这几个元素本身就是用于下一次计数排序的第一关键字了。</p><p>因为这些元素的第二关键字为0，这些元素在优化前的第一次计数排序完成后，都是直接排在最开始的连续位置。（连续长度为w）。</p><p>从下一次计数排序的视角讲，下一次计数排序只是在上一次给出的有序性的基础上进行。但是对于前面这几个元素来讲，它们第二关键字对应的rank一定都是0，即认为相等。（因为这些第二关键字的下标已经大于n了。而rk数组在初始化的时候，其&gt;n的部分都是0.）</p><p>因为rk中这些第二关键字都是0，所以在后续生成新的rk数组时，凡是提到它们的第二关键字的rk，永远都是恒等于0的值。</p><p>回想这段生成新rk数组的算法:</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (p &#x3D; 0, i &#x3D; 1; i &lt;&#x3D; n; i++) oldrk[sa[i]] &#x3D;&#x3D; oldrk[sa[i - 1]] &amp;&amp; oldrk[sa[i] + w] &#x3D;&#x3D; oldrk[sa[i - 1] + w]? rk[sa[i]] &#x3D; p: rk[sa[i]] &#x3D; ++p;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>显然，这个条件：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">oldrk[sa[i] + w] &#x3D;&#x3D; oldrk[sa[i - 1] + w]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>是满足的。因为都是0.</p><p>则无论这些元素的第一关键字如何排列，都不会影响它们生成rk数组时，关于”相等“的判断。</p><p>所以我们可以任意把他们排列在sa的头w个位置，它们排列的情况有它们的全排列数种。</p><p>这里为了方便，我们采用降序排列在这里。</p><h4 id="将剩下的子串起始下标按在sa内的顺序，反推出其第一关键字下标，依次放进id"><a href="#将剩下的子串起始下标按在sa内的顺序，反推出其第一关键字下标，依次放进id" class="headerlink" title="将剩下的子串起始下标按在sa内的顺序，反推出其第一关键字下标，依次放进id"></a>将剩下的子串起始下标按在sa内的顺序，反推出其第一关键字下标，依次放进id</h4><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (i &#x3D; 1; i &lt;&#x3D; n; ++i) if (sa[i] &gt; w) id[++p] &#x3D; sa[i] - w;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这里的这些起始下标在sa中，意味着它们是以上一轮基数排序的顺序排列（单调不降）。</p><p>我们需要在这些下标中找到有可能成为第二关键字的下标，即筛选条件为：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">if (sa[i] &gt; w)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>按这些第二关键字的下标，反推其第一关键字的下标，并将这些下标放到id中。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">id[++p] &#x3D; sa[i] - w;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>这就相当于，当前id中保存了所有第一关键字按其第二关键字进行单调不降的排序的结果。</p><p>我们如果再进行一次单调不降的计数排序，就得到了子串长度为w的sa数组。</p><h3 id="常数优化：优化计数排序时关键字的值域"><a href="#常数优化：优化计数排序时关键字的值域" class="headerlink" title="常数优化：优化计数排序时关键字的值域"></a>常数优化：优化计数排序时关键字的值域</h3><p>该优化针对规模较大的源数组比较有用。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (w &#x3D; 1; w &lt; n; w &lt;&lt;&#x3D; 1，m &#x3D; p) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>即：在for循环的操作中，每次将m更新为p。</p><p>因为每轮生成新的RK数组时，p都被更新为当前RK数组的值域。</p><p>又因为计数排序是对RK数组的元素进行计数，所以可以通过这种方式来降低计数循环的循环次数上限。</p><p>例如：源数组为1e5的长度，那如果不优化，每次都要循环1e5去计数，这还没包括其他操作呢。1ms显然不够程序跑完。但是如果优化了，刚开始由于RK数组较小，m也就小，计数循环也就到不了1e5的级别。</p><h3 id="性能优化：减少不连续的访存"><a href="#性能优化：减少不连续的访存" class="headerlink" title="性能优化：减少不连续的访存"></a>性能优化：减少不连续的访存</h3><p>该优化针对规模较大的源数组比较有用。</p><p>我们格外维护一个px[]数组，大小和rk相符，令其满足px[i]=rk[id[i]].</p><p>在计数时，顺便把rk[id[i]]存给px[i]，如下：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (i &#x3D; 1; i &lt;&#x3D; n; ++i) ++cnt[px[i] &#x3D; rk[id[i]]];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>在后续访问时，都将rk[id[i]]用px[i]代替即可，如下：</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">for (i &#x3D; n; i &gt;&#x3D; 1; --i) sa[cnt[px[i]]--] &#x3D; id[i];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDUOJ 拉面馆题解 (编码和位运算)</title>
    <link href="/2021/04/09/SDUOJ%20-%205/"/>
    <url>/2021/04/09/SDUOJ%20-%205/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先定义t、s数组，分别用于存储面制作完成的时间点和顾客到达的时间点。</p><p>定义set st的数组，大小为8（即8个set构成的set数组），用于存储每种面（一种调料组合就被称为”一种”面）制作完成的时间。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>先输入n，m，k。</p><p>接下来开始循环处理制作的面，时间复杂度O(n)：用三位二进制数表示面里调料的有无。初始为0，即000。然后初始化一个当前调料为001.根据输入的调料编号，将上述001二进制数左移即可。最后根据上述二进制数的值和1-8依次做或，如果或运算等于后者，则说明该面含有的调料种类是后者的子集。将该碗面制作完成的时间放进st中。</p><p>接下来循环处理客人的到达，时间复杂度O(m*n): 用完全相同的方式得出客人需要的面的二进制数，并从st集合对应下标中取begin（利用set的有序性得到最早制作完成的面）。如果st集合该下标为空，代表需要的面不存在，则输出angry即可。否则存在，则需要删除这碗面：注意要再遍历set数组，把其中具有与此相同制作时间的面删除。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int inf &#x3D; 200010;set&lt;int&gt; st[8];     int t[inf], s[inf]; &#x2F;&#x2F;t[i]:每碗面制作完成的时间点int main()&#123;    int n, m, k; &#x2F;&#x2F;n:制作的面的数量 m:顾客的数量 k:配料的种类数    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        cin &gt;&gt; t[i];    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        int kk, v &#x3D; 0;            cin &gt;&gt; kk;        for (int j &#x3D; 1; j &lt;&#x3D; kk; j++)        &#123;            int x; &#x2F;&#x2F;该碗面含有的配料编号            cin &gt;&gt; x;            v |&#x3D; (1 &lt;&lt; (x - 1));         &#125;        for (int j &#x3D; 1; j &lt; 8; j++)        &#123;            if ((v &amp; j) &#x3D;&#x3D; j)             &#123;                st[j].emplace(t[i]);             &#125;        &#125;    &#125;    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    &#123;        cin &gt;&gt; s[i];     &#125;    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)    &#123;        int cc, v &#x3D; 0; &#x2F;&#x2F;cc:客人喜爱配料的种类数        cin &gt;&gt; cc;        for (int j &#x3D; 1; j &lt;&#x3D; cc; j++)        &#123;            int x;            cin &gt;&gt; x;            v |&#x3D; (1 &lt;&lt; (x - 1));         &#125; &#x2F;&#x2F; 代表该客人喜欢吃的配料            if (st[v].empty())     &#x2F;&#x2F;该客人喜欢吃的配料没有对应的面            &#123;                cout &lt;&lt; &quot;Angry\n&quot;;            &#125;            else            &#123;                int vv &#x3D; *st[v].rbegin();    &#x2F;                cout &lt;&lt; (s[i] - vv) &lt;&lt; &#39;\n&#39;;                 for (int j &#x3D; 1; j &lt; 8; j++)                &#123;                    st[j].erase(vv);                 &#125;            &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDUOJ 摆放垃圾桶题解 (简单贪心)</title>
    <link href="/2021/04/09/SDUOJ%20-%207/"/>
    <url>/2021/04/09/SDUOJ%20-%207/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先定义struct requirement，其中存放每个要求的l、r、k。</p><p>定义exsist，当前区间存在的垃圾桶个数。</p><p>ans，输出结果。</p><p>map sts，用于模拟数组，给出每个下标处是否有垃圾桶。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>先输入并构造各个要求。</p><p>对于每个要求，先从该要求的l遍历到r，收集这段区间内垃圾桶总个数（够了k就及时终止。）时间复杂度O（n）。</p><p>之后，如果垃圾桶不够，就从r往l遍历，如果放了桶就跳过，如果没放过桶就ans++，并且更新此处的sts为true，并让exist++，代表该区间又多了一个桶。如果exist够了k，则及时终止。时间复杂度O（n）。</p><p>输出结果即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;int INF &#x3D; 1e9;struct requirment&#123;int l;int r;int k;bool operator&lt; (requirment re)const &#123;return r &lt; re.r;&#125;requirment(int l_, int r_, int k_) :l(l_), r(r_), k(k_) &#123;&#125;&#125;;int n, m;int l, r, k;int exsist, ans;unordered_map&lt;int, bool&gt; sts;multiset&lt;requirment&gt; inputs;int main() &#123;&#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.in&quot;,&quot;r&quot;,stdin);&#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.out&quot;, &quot;w&quot;, stdout);cin &gt;&gt; n &gt;&gt; m;for (int yq &#x3D; 1; yq &lt;&#x3D; m; yq++) &#123;scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k);inputs.emplace(l, r, k);&#125;&#x2F;&#x2F;sort(inputs.begin(), inputs.end());for (auto ite &#x3D; inputs.begin(); ite !&#x3D; inputs.end(); ite++) &#123;exsist &#x3D; 0;for (int i &#x3D; ite-&gt;r; i &gt;&#x3D; ite-&gt;l; i--) if (sts[i]) &#123;exsist++;if (exsist &gt;&#x3D; ite-&gt;k)break;&#125;if (exsist &lt; ite-&gt;k) &#123;for (int i &#x3D; ite-&gt;r; i &gt;&#x3D; ite-&gt;l; i--) &#123;if (exsist &gt;&#x3D; ite-&gt;k)break;if (!sts[i]) &#123;sts[i] &#x3D; true;exsist++;ans++;&#125;&#125;&#125;&#125;cout &lt;&lt; ans &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDUOJ 看电影题解（流水线调度问题）</title>
    <link href="/2021/04/09/SDUOJ%20-%206/"/>
    <url>/2021/04/09/SDUOJ%20-%206/</url>
    
    <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先定义person结构体，存储a、b。</p><p>重载小于运算符，使该结构体的排序规则符合Johnson法则。</p><h2 id="Johnson法则"><a href="#Johnson法则" class="headerlink" title="Johnson法则"></a>Johnson法则</h2><p>对一个人，如果它的A时间&lt;=B时间，则与其同类的排序规则是按a升序；如果它的A时间&lt;B时间，则与同类的排序规则是按b降序。最后，将上述后一类人连接到前一类人的末尾，组成的整个序列就是最优的流水线调度序列。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>根据Johnson法则构造一个最优序列，按如下算法计算总时间即可：</p><p>对于A影院，无脑累加时间，并记录每个人观影结束时间。</p><p>对于B影院，如果当前累计时间小于下一个要来B看电影的人在A的结束时间，就让当前累计时间直接等于该人在A的结束时间。之后把该人在B看电影的花费时间再累加上去即可。</p><p>最后输出A影院时间累计和B影院时间累计的较大的一个。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;const int INF &#x3D; 1e9;struct Person&#123;int a &#x3D; 1, b &#x3D; 1;bool isA;Person(int a_, int b_, bool isA_) :a(a_), b(b_), isA(isA_) &#123;&#125;;bool operator&lt;(const Person&amp; p) const &#123;if (isA) return a &lt; p.a;return b &gt; p.b;&#125;&#125;;int n;unordered_map&lt;int, int&gt;a, b;vector&lt;Person&gt; peopleA;vector&lt;Person&gt; peopleB;vector&lt;int&gt; aEnd;int aTimeAcc &#x3D; 0, bEnd &#x3D; 0, bCntr &#x3D; 0;int main() &#123;&#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.in&quot;,&quot;r&quot;,stdin);&#x2F;&#x2F;freopen(&quot;C:\\Users\\Lenovo\\Desktop\\a.out&quot;, &quot;w&quot;, stdout);cin &gt;&gt; n;for (int i &#x3D; 1; i &lt;&#x3D; n; i++)cin &gt;&gt; a[i];for (int i &#x3D; 1; i &lt;&#x3D; n; i++)cin &gt;&gt; b[i];for (int i &#x3D; 1; i &lt;&#x3D; n; i++)a[i] &lt;&#x3D; b[i] ? peopleA.emplace_back(a[i], b[i], true) : peopleB.emplace_back(a[i], b[i], false);sort(peopleA.begin(), peopleA.end());sort(peopleB.begin(), peopleB.end());for (auto ite &#x3D; peopleA.begin(); ite !&#x3D; peopleA.end(); ite++) &#123;aTimeAcc +&#x3D; ite-&gt;a;aEnd.push_back(aTimeAcc);&#125;for (auto ite &#x3D; peopleB.begin(); ite !&#x3D; peopleB.end(); ite++) &#123;aTimeAcc +&#x3D; ite-&gt;a;aEnd.push_back(aTimeAcc);&#125;for (auto ite &#x3D; peopleA.begin(); ite !&#x3D; peopleA.end(); ite++) &#123;if (bEnd &lt; aEnd[bCntr]) bEnd &#x3D; aEnd[bCntr];bEnd +&#x3D; ite-&gt;b;bCntr++;&#125;for (auto ite &#x3D; peopleB.begin(); ite !&#x3D; peopleB.end(); ite++) &#123;if (bEnd &lt; aEnd[bCntr]) bEnd &#x3D; aEnd[bCntr];bEnd +&#x3D; ite-&gt;b;bCntr++;&#125;cout &lt;&lt; max(bEnd, aTimeAcc) &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hello everyone</title>
    <link href="/2021/03/15/hello-everyone/"/>
    <url>/2021/03/15/hello-everyone/</url>
    
    <content type="html"><![CDATA[<h3 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h3><p>哈哈哈！这里是第一篇博客~嗯。</p><p>这次连接到了域名~</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
